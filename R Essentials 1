We want users to be able to begin in an interactive environment, 
where they did not consiencely think of themselves as programming.
Then as their needs become clearer and their sophistication increased,
they should be able to slide gradually into programming,
when the language and system aspects would become more important.

Drawbacks:
There is little support for dynamic / 3D graphics

One of the big advantages of working with R is the ability to use libraries developed by users. 
The base R comes with the following preloaded set of libraries:
getOption("defaultPackages")  #base packages 

install.packages("BeyesCR") 
install.packages("BeyesCR", depends=TRUE)

library() #installed packages

Working directories
getwd() #default saving folderr

setwd("C:/Users/Curwan/Documents/") #set set to other directory
setwd("H:Documents/")

data = read.table(file="clipboard", header="TRUE") #Import excel file

q() #Quit session
CTR L #Clear All

x=10 #Use "=" or "<-" to assign/create object
x or print(x) #print output

objects() #Prints list of all the objects created in session
ls() #Prints list of all the objects created in session
rm(x) #Remove objects from workspace
character(0)

options(digets = 16) #Increase number of decimals

xx <- 1:10 #Create a series of 10 integers from 1 to 10.
yy <- rnorm(10) #Simulate 10 random observations from a standard normal distribution
plot(xx,yy) #Produce scatter plot

**NB HELP function using ? preceding the function
?getwd


Data Types in R - Different Objects:
Character, Numeric (Real), Integer, Complex Number, Logical (TRUE or FALSE)
Most basic Objects:
Vector - only contains objects of same class
List - vector with different class objects

attributes() #each object has attributes: Names (Dimnames), Dimensions, Class, Length
Inf - 1/0 special number to infinity
NaN - undefined number

vector() #create empty vector
x = vector("numeric", length = 10) #create vector
c() #concatenate function to create vectors
x = c(0.5, 0.6) #Numeric
x = c(TRUE, FALSE) or x = c(T,F) #Logical
x = c("a", "b", "c") #Character
x = c(1+0i, 2+4i) #Complex

If you create a vector and mix objects of different classes it will result in COERCION.
Implicit Coercion force the vector to take class of most number of entries.
x = c(1,"a") #Character
x = c(2, TRUE) #Numeric, since T & F are binary
x = c("a", TRUE) #Character

Explicit Coercion, you specify the object class:
x = 0:6
class(x) #print class of object x
as.numeric(x) #change class to numeric
as.logical(x) #
as.character(x)

x = c("a", "b", "c") #Explicit coercion is not always possible
as.numeric(x) #Resulting NA introduced by coercion
as.logical(x) #Cant change Strings as Factors


MATRICES are vectors that have a dimension attribute
m = matrix(nrow=2, ncol=3) #create empty matrix with 2 rows and 3 columns
dim(m)
attributes(m)

m = matrix(1:6, nrow=2, ncol=3) #Construct matrix column-wise (add numbers to each col first)

m = 1:10
dim(m) = c(2,5) #Take vector and add dimension attribute to create matrix

x = 1:3
y = 10:12
cbind(x,y) #Bind seperate columns to create matrix
rbind(x,y) #Bind seperate rows to create matrix

LISTS are special vectores with elements of different classes
x = list(1, TRUE, "a", 1+4i) #create list 

FACTORS are special vectors for Chategorical Data. Can be ordered or unordered and boolian.
x = factor(c("a", "b", "b", "a", "a", "b", "b")) #create factor
table(x) #create table of summed entries
unclass(x) #1-hot-encoding of characters

LEVELS argument in factor() function to order levels:
x = factor(c("A", "D", "N", "N", "A", "A", "A", "N", "D", "D"), levels = c("D", "N", "A"))
attr(x, "levels") #print different categorical entries

MISSING VALUES NaN>>NA
is.NA() - test if input is missing value, can have class
is.NaN() - test if input is not a number

DATA FRAME stores tabular data
Special type of list, each element (column) with same length (number of rows)
read.table() / read.csv() #create Data Frame, import data
x = data.frame(foo = 1:4, bar = c(T, F, T, T))
DF's are matrices that can store different classes of objects
data.matrix() #Convert DF to matrix
row.names #attribute
nrow(x) #number of rows
ncol(x) #number of columns

